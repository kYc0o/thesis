\chapter{Conclusions}
\label{sec:Conclusions}
Software engineering is a research domain that has reached a very mature status nowadays.
While its applications are intended to solve problems for very complex and large software systems, we have highlighted throughout this thesis some aspects that can be leveraged for their adoption on the Internet of Things.
More specifically, Model Driven Engineering has been studied on the context of distributed systems, since its similarities with the IoT seem evident.
Therefore, the scientific problems raised by this new paradigm are the same than those already covered for distributed applications.
However, the very different capacities and network topology of IoT systems make this adoption very challenging.
Indeed, we showed that the hardware constraints and energy autonomy typical of IoT nodes are the main obstacle to implement the solutions proposed by the MDE community \textit{"as is"}.

Our state of the art described this two domains on detail, presenting at first the new paradigm of the Internet of Things and its main characteristics as a typical distributed system, and second the most recent tools aiming to solve a common issue found on this two domains: the management of a distributed software layer for (self)adaptation purposes.
This management is very important in complex and large systems such as the presented on this thesis, since maintenance costs and services downtime can be drastically reduced by applying the right techniques.
Indeed, the existing approaches proposed to deal with this problem have shown their capacity to increase efficiency by providing several tools for developers and maintainers, leveraging abstract models that can be manipulated in a safer and easier way than the actual system.
Moreover, decoupling of these large systems into small software components easy to maintain has been presented as an excellent complement to provide adaptation mechanisms, by facilitating their replacement and addition of new ones, resulting in new behaviors.
Thus, their promising results have been the source of inspiration to us to investigate their main principles for their adoption on very resource constrained environments such as the IoT.

Our first contribution make use of these models, known as \textit{"models@runtime"}, to provide an abstract representation of a whole IoT network, including the running applications, their current state of execution and bindings between components.
The implementation of this approach is inspired from the Kevoree meta-model, taking into account the very scarce resources found on IoT devices.
We first show that the use of models@runtime on IoT devices is possible, with a small overhead compared to the benefits of the model representation.
Indeed, our experiments determined the limits of this approach, by calculating an approximate number of maximum nodes and components that can be present on the model before exhausting the memory capacities of a typical IoT device.
Afterwards, we highlighted the system facilities necessary to execute the adaptations generated by a model manipulation (changes on the current model).
These facilities have been extended for our target IoT nodes, in order to provide a complete experimentation platform which fits our requirements.

Thus far, we provided a mechanism to reflect our system in the form of a model@runtime and synchronize the current execution state to match with its representation.
In order to provide the adaptation mechanisms, a component model based on dynamic loading of code has been implemented, relying on the possibility of the underlying system to do so.
This component model follows the same Kevoree meta-model representation, which can also be synchronized together with the IoT node and network characteristics.

Our second contribution highlights the very specific problem of components distribution, found in IoT environments due to the network topology.
Indeed, this problem is not present in typical distributed systems, since they rely its communication means on very robust, fast and reliable networks.
We argue that component downloading using epidemic dissemination of components reduces the capacity to finely select the nodes to be updated/extended, since state of the art protocols are not guided by an abstract representation of the system.
In addition, individual downloading of components can use several nodes on a mesh topology, in order to reach the component repository.
In most of cases, these nodes are used several times to forward the same content requested by different nodes, thus energy is wasted using this approach.
Therefore, a new algorithm has been proposed to deal with the high energy consumption while transmitting software artifacts through a mesh network, typical of the IoT.
Our approach, called \textit{Calpulli}, leverage the knowledge of the network topology through a typical IoT routing protocol, RPL, coupled with the application information available on the model, to find the best path and caching mechanisms for artifacts downloading.
The evaluation of our approach showed that even in a small representative network, the benefits of using such an algorithm are important regarding the energy consumption.

\chapter{Perspectives}
\label{sec:Perspectives}
The presented research work has shown that software engineering tools coupled with a fine knowledge of the constraints found in IoT systems are able to enable adaptation features for this large distributed systems.
Indeed, several perspectives are open for future work:

\begin{description}
	\item[Modeling tools for accurate code generation.] Our current implementation relies on a manual transformation of the Kevoree meta-model in order to provide the C code that can be compiled for the Contiki OS.
	Therefore, automatic tools inspired, for instance, from KMF\cite{fouquet2012eclipse}, can be leveraged to provide a flexible framework which enables a more versatile meta-model implementation, in addition to a more accurate code generation.
	Moreover, using high level modeling tools can lead to optimizations on the generated code, since changes on the abstract representation are easier to perform than manual coding.
	\item[A flexible component development framework.] The programming model used to implement components for resource constrained devices can have strong dependencies on the underlying OS.
	Indeed, our approach can be extended to support high level modeling tools to provide the right code depending on the chosen OS, avoiding specific development restrictions, since the component model is already provided.
	\item[Leverage ICN mechanisms for more accurate components distribution.] Our presented protocol \textit{Calpulli} shares several principles that are being investigated by the Information-Centric Networking (ICN)\cite{ahlgren2012survey}.
	Indeed, this paradigm explores in-network caching, multiparty communication through replication, and interaction models decoupling senders and	receivers.
	The goal is, as for \textit{Calpulli}, to provide the best mechanisms for highly scalable and	efficient distribution of content to better cope with disconnections, disruptions, and flash crowd effects in the communication service.
	It is then possible to apply such approach, in order to have energy savings as a side effect. 
\end{description}

\section*{Experimenting with larger and more controlled IoT neworks}
We have conducted a set of experiments to highlight the performance of \textit{Calpulli}, our algorithm which leverages model@runtime information to reduce the energy consumption and time to distribute software components over an IoT network.
This set of experiments have been conducted on a rather small network (i.e. 10 nodes) which  may limit our ability to draw a conclusion on larger IoT system.
%The small number of nodes is due to a current limitation of our Kevoree-IoT implementation which loads the entire model on each node.
Thus, efforts in optimizing the use of memory on constrained devices can be done in order to increase its efficiency.
Indeed, better mechanisms for model loading on RAM can result in a more lightweight implementation, which can be able to represent larger models and speed up the de-serialization process.
%Moreover, as the network topology is hard to control under the IoT-Lab environment coupled with the memory constraints of our IoT nodes, the current implementation is not able to support more than 10 nodes and 10 components in the model for an experiment on the testbed. 
While we acknowledge this limitation in our current set of experiments, we believe that the good results demonstrated on this small scale network will tend to be amplified on a larger network since the algorithm is completely decentralized and has been designed with a larger network infrastructure in mind.
Therefore, improvements on this algorithm can be introduced by the use of more efficient network protocols such as 6TiSCH\cite{dujovne20146tisch} coupled with ICN already presented above.