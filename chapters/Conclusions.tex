\chapter{Conclusions}
\label{sec:Conclusions}
Software engineering is a research domain that has reached a very mature status nowadays.
While its applications are intended to solve problems for very complex and large software systems, we have highlighted throughout this thesis some aspects that can be leveraged for their adoption to solve problems related to software management on the Internet of Things.
More specifically, Model Driven Engineering has been studied on the context of distributed systems, since its similarities with the IoT seem evident.
Therefore, the scientific problems raised by this new paradigm are the same than those already covered for distributed applications.
However, the very different capacities and network topology of IoT systems make this adoption very challenging.
Indeed, we showed that the hardware constraints and energy autonomy typical of IoT nodes are the main obstacle to implement the solutions proposed by the MDE community \textit{"as is"}.

\section{From IoT to MDE}
Our state of the art described these two domains in detail, presenting at first the new paradigm of the Internet of Things and its main characteristics as a typical distributed system, and second the most recent tools aiming to solve a common issue found on this two domains: the management of a distributed software layer for (self)adaptation purposes.
This management is very important in complex and large systems such as the presented on this thesis, since maintenance costs and services downtime can be drastically reduced by applying the right techniques.
Indeed, the existing approaches proposed to deal with this problem have shown their capacity to increase efficiency by providing several tools for developers and maintainers, leveraging abstract models that can be manipulated in a safer and easier way than the actual system.
Moreover, dividing these large systems into small software components easier to maintain has been presented as an excellent complement to provide adaptation mechanisms, by facilitating their replacement and addition of new ones, resulting in new behaviours.
Thus, these promising results have been the source of inspiration to us to investigate the main principles for their adoption on very resource constrained environments such as the IoT.

\section{Models@runtime to manipulate IoT software}
Our first contribution make use of these models, known as \textit{"models@runtime"}, to provide an abstract representation of a whole IoT network, including the running applications, their current state of execution and bindings between components.
The implementation of this approach is inspired from the Kevoree meta-model, taking into account the very scarce resources found on IoT devices.
We first show that the use of models@runtime on IoT devices is possible, with a small overhead compared to the benefits of the system representation through a model.
Indeed, our experiments determined the limits of this approach, by calculating an approximate number of maximum nodes and components that can be present on the model before exhausting the memory capacities of a typical IoT device.
Afterwards, we highlighted the system facilities necessary to execute the adaptations generated by a model manipulation (changes on the current model).
These facilities have been extended for our target IoT nodes, in order to provide a complete experimentation platform which fits our requirements.

Thus far, we provided a mechanism to reflect our system in the form of a model@runtime and synchronize the current execution state to match with its representation.
In order to provide the adaptation mechanisms, a component model based on dynamic loading of code has been implemented, relying on the possibility of the underlying system to actually load new code.
This component model follows the same Kevoree meta-model representation, which can also be synchronized together with the IoT node and network characteristics.

We can highlight that the use of a model@runtime to manage the software layer in IoT devices is possible, and adds an abstraction layer which facilitates the distribution of tasks among different nodes on the IoT, thanks to the components decoupling of the whole system.

\section{Towards "content caching" via \textit{Calpulli}}
Our second contribution highlights the very specific problem of components distribution, found in IoT environments due to the network topology.
Indeed, this problem is not present in typical distributed systems, since they rely its communication means on very robust, fast and reliable networks.
We argue that component downloading using epidemic dissemination of components reduces the capacity to finely select the nodes to be updated/extended, since state of the art protocols are not guided by an abstract representation of the system.
In addition, individual downloading of components can use several nodes on a mesh topology, in order to reach the component repository.
In most of cases, these nodes are used several times to forward the same content requested by different nodes, thus energy is wasted using this approach.
Therefore, a new algorithm has been proposed to deal with the high energy consumption while transmitting software artefacts through a mesh network, typical of the IoT.
Our approach, called \textit{Calpulli}, leverage the knowledge of the network topology through a typical IoT routing protocol, RPL, coupled with the application information available on the model, to find the best path and caching mechanisms for artefacts downloading.
The evaluation of our approach showed that even in a small representative network, the benefits of using such an algorithm are important regarding the energy consumption.

In summary, our algorithm for component caching results in a very efficient way to distribute software artefacts among the nodes present in an IoT network, while saving a considerable amount of energy.
Moreover, this algorithm will perform better as the network grows.

In overall, we can conclude that mechanisms for software management in very large, heterogeneous and non-monolithic distributed systems, as the Internet of Things, are necessary, due to the high efforts required to maintain the life-cycle of software running on these platforms.
Moreover, we highlighted that IoT systems require specific mechanisms to provide such management, since the target nodes are very different to typical nodes present in distributed systems.
Indeed, the constrained resources and network environment make the development of management tools very challenging.
Therefore, the proposed approaches and algorithms to perform this task are the firsts steps towards a more complete framework to support dynamic behaviour and self-adaptation on the Internet of Things, as it was presented  throughout this thesis.

\chapter{Perspectives}
\label{sec:Perspectives}
The presented research work has shown that software engineering tools coupled with a fine knowledge of the constraints found in IoT systems are able to enable adaptation features for this large distributed systems.
Indeed, several perspectives are open for future work.
The next sections will present them in detail.

\section{Modelling tools for accurate code generation}
Our current implementation relies on a manual transformation of the Kevoree meta-model in order to provide the C code that can be compiled for the Contiki OS.
Therefore, automatic tools inspired, for instance, from KMF \cite{fouquet2012eclipse}, can be leveraged to provide a flexible framework which enables a more versatile meta-model implementation, in addition to a more accurate code generation.
Moreover, using high level modelling tools can lead to optimizations on the generated code, since changes on the abstract representation are easier to perform than manual coding.

\section{A flexible component development framework} 
The programming model used to implement components for resource constrained devices can have strong dependencies on the underlying OS.
Indeed, our approach can be extended to support high level modelling tools to provide the right code depending on the chosen OS, avoiding specific development restrictions, since the component model is already provided.

\section{Leverage ICN mechanisms for efficient components distribution}
Our presented protocol, \textit{Calpulli}, shares several principles that are being investigated by the Information-Centric Networking (ICN) \cite{ahlgren2012survey}.
Indeed, this paradigm explores in-network caching, multi-party communication through replication, and interaction models decoupling senders and	receivers.
The goal is, as for \textit{Calpulli}, to provide the best mechanisms for highly scalable and efficient distribution of content to better cope with disconnections, disruptions, and flash crowd effects in the communication service.
In our particular case, software component distribution, these mechanisms are of high interest, since reductions on retransmissions of the same content lead to energy savings.
It is then interesting to investigate such approach, and to explore the possibilities to leverage our model-based approach to improve its efficiency. 


%\section*{Experimenting with larger and more controlled IoT networks}
%We have conducted a set of experiments to highlight the performance of \textit{Calpulli}, our algorithm which leverages model@runtime information to reduce the energy consumption and time to distribute software components over an IoT network.
%This set of experiments have been conducted on a rather small network (i.e. 10 nodes) which  may limit our ability to draw a conclusion on larger IoT system.
%The small number of nodes is due to a current limitation of our Kevoree-IoT implementation which loads the entire model on each node.
%Thus, efforts in optimizing the use of memory on constrained devices can be done in order to increase its efficiency.
%Indeed, better mechanisms for model loading on RAM can result in a more lightweight implementation, which can be able to represent larger models and speed up the de-serialization process.
%Moreover, as the network topology is hard to control under the IoT-Lab environment coupled with the memory constraints of our IoT nodes, the current implementation is not able to support more than 10 nodes and 10 components in the model for an experiment on the testbed. 
%While we acknowledge this limitation in our current set of experiments, we believe that the good results demonstrated on this small scale network will tend to be amplified on a larger network since the algorithm is completely decentralized and has been designed with a larger network infrastructure in mind.
%Therefore, improvements on this algorithm can be introduced by the use of more efficient network protocols such as 6TiSCH \cite{dujovne20146tisch} coupled with ICN already presented above.