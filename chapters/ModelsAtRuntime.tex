\chapter{Managing software deployment in distributed systems}
\label{sec:managingDS}
As we discussed in the precedent chapter, we can compare classical distributed systems with IoT systems.
Since they share both the high number of participating nodes and the collaborative approach to offer services, the existing proposed solutions to manage the software layer in classical distributed systems are of high interest, and can provide a good insight for their adoption in the IoT.
In order to reliably manage the life cycle of these large information systems, approaches coming from Software Engineering (SE), such as Component-Based Software Engineering (CBSE)\cite{crnkovic2002building}, have been proposed.

\section{Component Based Software Engineering (CBSE)}
\label{sec:CBSE}
Several definitions to CBSE have been proposed in the literature, being the notion of \textit{component} the main principle.
In a general way, CBSE aims to leverage the main benefits of SE in terms of development, integration, maintenance, reusability, separation of concerns, among others.
However, a more specific definition was proposed by Szyperski\cite{szyperski2002component}, being one of the most used:
\begin{citeverbatim}
	"A software component is a unit of composition with contractually specified interfaces and explicit context dependencies only. A software component can be deployed independently and is subject to composition by third parties".
\end{citeverbatim}
In another definition, Heineman \textit{et al.}\cite{heineman2001cbse} define a component as:
\begin{citeverbatim}
	"A component model defines a set of standards for component implementation, naming interoperability, customization, composition, evolution and deployment".
\end{citeverbatim}
We can note that this definition puts more emphasis in the development model, which leverages not only the abstract system composition, but also covers the global system deployment from the underlying pieces.

The main characteristics of a component can be summarized as follows:
\begin{itemize}
	\item \textbf{Interfaces specification.} The available functionalities of a component.
	\item \textbf{Explicit dependencies.} A component could require other component's functionalities or native libraries to work correctly.
	If so, such requirements should be exposed.
	\item \textbf{Instantiation.} Multiple instances of the given type can exist.
	\item \textbf{Deployment independence.} A deploy unit represent the whole component, which can be reused. However, this feature can be discussed.
\end{itemize}
Moreover, a component-based approach defines an \textit{Architecture Description Language (ADL)}.
This is useful to describe the structure of a software, in a formal way\cite{taylor2009architectural}\cite{len2003software}\cite{medvidovic2000classification}.
They are declarative languages that describe a system's architecture as a set of components, connectors, bindings and configurations.
Such a language can be used to assemble components, based in two elements:

\begin{itemize}
	\item \textbf{Instances.} They are the main elements which actually embody the required application's functionalities, constituting the business logic.
	\item \textbf{Connectors.} A link between component's instances, determined by the exposed provided and required functionalities of the used types.
\end{itemize}

For the purpose of separate concerns, the notion of \textit{container} was introduced in the CBSE community, in order to identify and separate the functional code from the non-functional code.
The component's structure follows this principle, separating concerns such as transactions, persistence or security, from business logic.
A container can be represented by the figure X. \todo{make a container figure}

%Le code métier du composant est englobé dans un conteneur qui prend en charge certains aspects non-fonctionnels en suivant les spécifications données par l’utilisateur ainsi que la gestion du cycle de vie du composant. 
%Il existe de nombreuses implantations de modèles à composants détaillées et comparées dans [Cer04]. 
%Ces implantations se focalisent en général sur un unique aspect non-fonctionnel, par exemple, la communication par événements des JavaBeans [Sunc], ou encore les transactions et la persistance des données gérée par les EJB 21 [Suna]. 
%Comme un certain nombre d’aspects non-fonctionnels sont récurrents dans les approches à composants, il existe des bibliothèques standard de code non-fonctionnel. 
%Cependant, certaines approches laissent l’utilisateur libre de définir ses propres aspects non-fonctionnels ; ces approches sont dites approches à composants extensibles, Fractal [Obj04] en est un exemple.
\subsection{Classical CBSE approaches}



%A propos du chapitre 3 :
%Le titre devrait être : Deployment in distributed systems
%L'introduction devrait pas être du background de nouveau, car la transition doit être fait en fin de chapitre 2.
%Personnellement, je changerai l'ordre c'est pas très logique. 
%Je mettrais le CBSE en premier car cela correspond à l'approche traditionnel pour faire du déploiment en système distribué, et je pense que c'est ce qu'il faut dire au début.
%Ensuite tu parles du M@R (en le présentant comme une évolution du CBSE) et à l'intérieur tu peux parler du MDE. Mais le MDE dans l'absolu ce n'est pas important pour toi. etc...


\section{Models@Runtime (M@R)}
With a view to ease software development for these very complex information systems, Model Driven Engineering (MDE) focus on, at first, giving simple, abstract and different points of view of information systems, without modify the actual system. 
In a second place, a variant of the MDE approach, called Model Driven Architecture (MDA)\cite{kleppe2003mda} aims to provide, through Domain Specific Languages (DSLs) coupled with code generators, software development tools and methods.
This approach is able to generate executable code from the abstract model, that can be generated for different hardware architectures.
Moreover, while heterogeneity of target architectures is taken into account through multiple generators, they also imposes a V cycle of development\cite{fouquet2013kevoree}, which consists in:
\begin{itemize}
	\item Context design of the abstract system ("Meta-model" and code generators)
	\item Use-case design (model)
	\item Executable code from the model
\end{itemize}
Even if this V cycle responds to the large complexity, it could not be enough to respond in terms of software plasticity that will be present in the very changing IoT environment.

Classical information systems are nowadays a critical piece of many important processes as well as industrial than commercial.
Downtime of this systems can represent a big economic loss, therefore robustness and continuous availability should be assured.
Thus, we can treat them as \textit{eternal systems}.
Furthermore, the evolution of the needs and the rapid obsolescence of features imposes an openness to new functionalities that were not predictable at design time.
In IoT systems, we can take the example given in subsection \ref{subsec:effBuilding}, in which evolutions of a building were complicated to predict.
It was even more difficult to provide a prepared software platform able to deal with new features and devices, avoiding the rapid availability of new services.
However, this new behavior must be implemented in the future due to the new energy policies, without alter the current given services.

We can consider this critical systems as \textit{Dynamic Adaptive Systems} (DAS)\cite{mckinley2004composing}, \cite{morin2009taming}.
Continuous update mechanisms are then carried into the target platforms, in order to change at runtime the software already deployed.
Taking into account this dynamic behavior, DAS are defined using a paradigm based on components, being the management of these components' deployment an evolution of the approach. %which allows to decouple this big systems into software pieces that are easily maintainable\cite{crnkovic2002building}.

DAS were typically deployed in critical platforms such as airports or banks, which had no tolerance to downtimes.
However, in the last years the pervasiveness of software in all domains demand a downtime rate near to 0, including phones, domestic Internet gateways and domotic services\cite{nain2008using}.
This requirements need to be supported by continuous updates, even for this non-critical systems.
Even if today IoT systems are not widely deployed, its importance in the near future justify its design in the form of a DAS.

The development model was also changed drastically, in order to follow the software plasticity present in this systems.
When V cycle was widely used and preferred over other development methods in the 80's, coming from the design and initial specification to the code generation or implementation, nowadays Agile methods\cite{stolberg2009enabling}, which aim to bring in shorter development cycles, are more recommended and used, in order to respond more quickly to specification evolutions thanks to users feedback.
Combined to this, the new approach of Continuous Integration (CI) introduces a new test system able to be updated with new artifacts of continuous development.
By adopting such a methodology, non-critical systems and DAS specified constraints are brought more closely, supporting the idea of move together abstractions of this two domains.

Therefore, the V approach from the 80's is becoming obsolete, while agile methods tend to expand it at every development cycle.
It is then possible to develop and deploy software for critical and non-critical systems in a continuous manner.
MDE approaches to generate code, and especially the MDA unidirectional approach which leverages a model to produce code, must take into account the inherent bidirectional development model of this continuous cycle.
Moreover, generators must provide reverse operations to allow cyclic code, which can be present at design time.
This can be useful to deal with legacy code as much as at design time, which is one of the main concerns of MDE, as in the tooling, beyond an approach of design to code.

\subsection{M@R in Dynamic Adaptive Systems}
A new paradigm named \textit{Model@Runtime} (M@R) aim to combine MDE techniques with tangible systems, in order to respond to the problem of cyclic design stated previously.
As MDE, M@R were useful at first as a thoughtful visualization of a system, for simulation purposes\cite{oreizy1999architecture}, \cite{blair2009models}, \cite{zhang2006model}.
A \textit{permanent updated} model is then used to represent abstractly a DAS at runtime.
Every different element composing this model can be represented in a schema, providing an easy navigation and an introspective analysis through the model layer.
Reasoning about the state of the system is also possible using the same layer.
Leveraging not only the introspection capability of the model, but also the intersection, Brice Morin\cite{morin2010leveraging} worked with this Model@Runtime layer aiming to modify it, through the reflexive model representation.
Using intersection allows to modify the internal state of a system\cite{paepcke1993object}.
Morin's M@R approach aim to build systems with reflexive capacities, having also intersection and introspection features present in the same layer.
As an abstract layer, the proposed reflexivity can be asynchronous, allowing modifications before affecting the real system, i.e. for testing purposes. 

This asynchronous properties separate strongly the actual system and the model, giving to MDE techniques the possibility to manipulate the reflexive layer without affecting at all the running platform.
Moreover, a schematic representation leveraging the reflexive layer can be extracted from the actual system, in order to modify it.
This modification can be in the form of component's adding or removal in the extracted model, then thanks to a version comparison between both the actual and the modified model, it is possible to actually trigger updates on the platform.
A bidirectional connexion also exists, since any modification to the external platform will be reflected in the M@R layer.
Modifications in the model can be manipulated before the deployment allowing verifications, in addition to a more flexible way to test different configurations.
For instance, if we want to deploy components with dependencies, the platform itself will avoid the deployment if any of the dependency is not met.
At the model level, the same changes can be executed regardless of the order, if the adaptation execution is done after the adding/removal of the components, being the model less constrained than the platform.
While the restrictions of the platform avoid the direct use of MDE approaches to manage the adaptations, the model can be manipulated to delay this restrictions in the application of the reflexive model, allowing to MDE approaches manipulate the model without following any order.

Approaches such as feature models or aspects\cite{morin2009taming} coupled with composition algorithms, can leverage the asynchronous capabilities of M@R in order to compose a model from the DAS architecture.
Since all operations can be done \textit{offline}, no constraints are imposed by the tangible platform before the deployment, while the system can decide when to synchronize.
Conceiving and composing models is then essential to assemble a whole DAS.
Several paradigms of composition are also needed, based in previous works\cite{morin2009mar},\cite{ko2012low},\cite{rouvoy2009music}, that encourage the use of software components to encapsulate the life cycle and composition operators.
Moreover, this paradigms are also needed to explore the exploitation viability at this granularity level, in order to manage the different parts of DAS application layer. 

\subsection{A DAS based on the IoT: Challenges}
Given the complexity and the vast heterogeneity of an IoT architecture, this thesis proposes the use of a M@R approach to manage the life cycle of the software deployed in this systems.
The approach will follow the directions given by the research already done by Fran{\c{c}}ois Fouquet\cite{fouquet2013kevoree}, previously based on Brice Morin's thesis\cite{morin2010leveraging}.
The DAS representation of the IoT will result, as in the mentioned thesis, in a Dynamic DAS (DDAS), in which we found a very different behavior than in traditional DDAS, such as Data Centers or Cloud Computing.
The challenges raised by such an approach in an IoT environment are, first of all, linked to the constrained environment already described in section \ref{subsec:constrainedObj}.
As the current implementations of the M@R paradigm are done in high level languages, one main challenge is to adapt such implementations to development environments for embedded systems in which we cannot make use of such languages, resulting in a difficult development task.
Moreover, the decoupling of components in modern operating systems is facilitated by Inter Process Communication (IPC) APIs already provided.
In the OS described in section \ref{subsec:IoTOS}, and more particularly in Contiki, which is used in this thesis, IPC are less evident nor standard.
Thus, a new way to implement components must be proposed following the directions discussed in section \ref{sec:CBSE}.
A second challenge resides in the network topology typical of IoT.
Being a multi-hop communication the mainly used approach to reach nodes in the IoT, different abstractions are needed to take it into account.
Furthermore, the network traffic must be reduced to a minimum, since wireless devices use batteries to work, and being communication the most energy consuming task of an IoT node.


%An IoT system is very complex and should be implemented as a DAS.
%This is important because the management of IoT infrastructures is impossible if the current approaches still being used, since each subsystem is treated as a separated entity of the whole system.
%The limitations given by the hardware of IoT devices must be taken into account, while providing the means to reach an abstraction level typical of DAS design.
%The very hard task to decouple an embedded application into small pieces should be coped using a CBSE approach, since works converge in the use of this method for DAS

\subsection{Special distributed systems: Wireless Sensor Networks}

\section{Kevoree}